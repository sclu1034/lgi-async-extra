<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lgi-async-extra</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>


<aside id="sidebar" class="has-background-white-ter">
    <h1 class="title"><a href="https://github.com/sclu1034/lgi-async-extra">lgi-async-extra</a></h1>
    <nav class="menu">
        <ul class="menu-list">
            <li><a class="" href="../index.html">Index</a></li>
        </ul>
        <p class="menu-label">Source</p>
        <ul class="menu-list">
            <li>
                <a class="is-active">file.lua</a>
                <ul>
                </ul>
            </li>
            <li><a href="../source/filesystem.lua.html">filesystem.lua</a></li>
            <li><a href="../source/stream.lua.html">stream.lua</a></li>
        </ul>
        <p class="menu-label">Modules</p>
        <ul class="menu-list">
            <li><a href="../modules/file.html">file</a></li>
            <li><a href="../modules/filesystem.html">filesystem</a></li>
            <li><a href="../modules/stream.html">stream</a></li>
        </ul>
    </nav>
</aside>
<div id="content" class="content__wrapper">
    <section class="section section__raw-content">
        <div class="container content"><h2>file.lua</h2>
<pre>
<span class="comment">---------------------------------------------------------------------------
</span><span class="comment">--- High level file handling library.
</span><span class="comment">--
</span><span class="comment">-- A file handle can be created through one of the constructor functions. File
</span><span class="comment">-- operations are performed on that handle.
</span><span class="comment">--
</span><span class="comment">-- Example to write and read-back a file:
</span><span class="comment">--
</span><span class="comment">--    local lgi = require("lgi")
</span><span class="comment">--    local File = require("lgi-async-extra.file")
</span><span class="comment">--    local path = "%s/foo.txt":format(lgi.GLib.get_tmp_dir())
</span><span class="comment">--    local f = File.new_for_path(path)
</span><span class="comment">--    async.waterfall({
</span><span class="comment">--        function(cb)
</span><span class="comment">--            -- By default, writing replaces any existing content
</span><span class="comment">--            f:write("hello", cb)
</span><span class="comment">--        end,
</span><span class="comment">--        function(cb)
</span><span class="comment">--            -- But we can also append to the file
</span><span class="comment">--            f:write("world", "append", cb)
</span><span class="comment">--        end,
</span><span class="comment">--        function(cb)
</span><span class="comment">--            f:read_string(cb)
</span><span class="comment">--        end,
</span><span class="comment">--    }, function(err, data)
</span><span class="comment">--        print(err)
</span><span class="comment">--        print(data)
</span><span class="comment">--    end)
</span><span class="comment">--
</span><span class="comment">-- @module file
</span><span class="comment">-- @license GPL v3.0
</span><span class="comment">---------------------------------------------------------------------------
</span>
<span class="keyword">local</span> async = <span class="global">require</span>(<span class="string">"async"</span>)
<span class="keyword">local</span> lgi = <span class="global">require</span>(<span class="string">"lgi"</span>)
<span class="keyword">local</span> Gio = lgi.Gio
<span class="keyword">local</span> GLib = lgi.GLib
<span class="keyword">local</span> GFile = Gio.File

<span class="keyword">local</span> stream_utils = <span class="global">require</span>(<span class="string">"lgi-async-extra.stream"</span>)


<span class="comment">-- Class marker
</span><span class="keyword">local</span> FILE_CLASS_MARKER = <span class="global">setmetatable</span>({}, { __newindex = <span class="keyword">function</span>() <span class="keyword">end</span>, __tostring = <span class="string">"File"</span> })


<span class="keyword">local</span> File = {
    class = FILE_CLASS_MARKER,
}
<span class="keyword">local</span> file = {}


<span class="comment">--- Constructors
</span><span class="comment">-- @section constructors
</span>
<span class="comment">--- Create a file handle for the given local path.
</span><span class="comment">--
</span><span class="comment">-- This is a cheap operation, that only creates an in memory representation of the resource location.
</span><span class="comment">-- No I/O will take place until a corresponding method is called on the returned `File` object.
</span><span class="comment">--
</span><span class="comment">-- @tparam string path
</span><a id="63"></a><span class="comment">-- @treturn File
</span><span class="keyword">function</span> file.new_for_path(path)
    <span class="keyword">local</span> f = GFile.new_for_path(path)
    <span class="keyword">local</span> ret = {
        _private = {
            f = f,
            path = path,
        }
    }
    <span class="keyword">return</span> <span class="global">setmetatable</span>(ret, { __index = File  })
<span class="keyword">end</span>


<span class="comment">--- Create a file handle for the given remote URI.
</span><span class="comment">--
</span><span class="comment">-- This is a cheap operation, that only creates an in memory representation of the resource location.
</span><span class="comment">-- No I/O will take place until a corresponding method is called on the returned `File` object.
</span><span class="comment">--
</span><span class="comment">-- @tparam string uri
</span><a id="82"></a><span class="comment">-- @treturn File
</span><span class="keyword">function</span> file.new_for_uri(uri)
    <span class="keyword">local</span> f = GFile.new_for_uri(uri)
    <span class="keyword">local</span> ret = {
        _private = {
            f = f,
            path = uri,
        }
    }
    <span class="keyword">return</span> <span class="global">setmetatable</span>(ret, { __index = File  })
<span class="keyword">end</span>


<span class="comment">--- Create a new file in a directory preferred for temporary storage.
</span><span class="comment">--
</span><span class="comment">-- If `template` is given, it must contain a sequence of six `X`s somewhere in the string, which
</span><span class="comment">-- will replaced by a unique ID to ensure the new file does not overwrite existing ones. The template must not contain
</span><span class="comment">-- any directory components.
</span><span class="comment">-- If `template == nil`, a default value will be used.
</span><span class="comment">--
</span><span class="comment">-- The directory is determined by [g_get_tmp_dir](https://docs.gtk.org/glib/func.get_tmp_dir.html).
</span><span class="comment">--
</span><span class="comment">-- The second return value is a `Gio.FileIOStream`, which contains both an input and output stream to the created
</span><span class="comment">-- file. The caller is responsible for closing these streams.
</span><span class="comment">--
</span><span class="comment">-- The third return value will be an instance of `GLib.Error` if the attempt to create the file failed. If this
</span><span class="comment">-- is not `nil`, attempts to access the other return values will result in undefined behavior.
</span><span class="comment">--
</span><span class="comment">-- See [docs.gtk.org](https://docs.gtk.org/gio/type_func.File.new_tmp.html) for additional details.
</span><span class="comment">--
</span><span class="comment">-- @tparam[opt=".XXXXXX"] string template
</span><span class="comment">-- @treturn File
</span><span class="comment">-- @treturn GIO.FileIOStream
</span><a id="115"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> file.new_tmp(template)
    <span class="keyword">local</span> f, stream, err = GFile.new_tmp(template)
    <span class="keyword">local</span> ret = {
        _private = {
            f = f,
            template = template,
        }
    }
    <span class="keyword">return</span> <span class="global">setmetatable</span>(ret, { __index = File  }), stream, err
<span class="keyword">end</span>


<span class="comment">--- Static functions
</span><span class="comment">-- @section static_functions
</span>
<span class="comment">--- Checks if a table is an instance of <a href="../modules/file.html#">file</a>.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><span class="comment">-- @usage local File = require("lgi-async-extra.file")
</span><span class="comment">-- local f = File.new_for_path("/tmp/foo.txt")
</span><span class="comment">-- assert(File.is_instance(f))
</span><span class="comment">-- @tparam table f The value to check.
</span><a id="138"></a><span class="comment">-- @treturn boolean
</span><span class="keyword">function</span> file.is_instance(f)
    <span class="keyword">return</span> <span class="global">type</span>(f) == <span class="string">"table"</span> <span class="keyword">and</span> f.class == FILE_CLASS_MARKER
<span class="keyword">end</span>


<span class="comment">--- @type file
</span>

<span class="comment">--- Creates a final callback to pass results and clean up the file stream.
</span><span class="comment">--
</span><span class="comment">-- This is intended to be passed as `final_callback` parameter for an `async.dag` where a Gio stream was
</span><span class="comment">-- opened at index `stream`.
</span><span class="comment">-- The `result_index` parameter is required to be set. If no result should be passed, provide `nil`.
</span><span class="comment">--
</span><span class="comment">-- @tparam nil|string result_index Index into the `async.dag` results table.
</span><span class="comment">-- @tparam[opt="stream"] string stream_index Index into the `async.dag` results table.
</span><span class="comment">-- @tparam function cb The callback to proxy
</span><span class="comment">-- @treturn function
</span><span class="keyword">local</span> <span class="keyword">function</span> clean_up_stream(result_index, stream_index, cb)
    <span class="keyword">if</span> <span class="global">type</span>(stream_index) == <span class="string">"function"</span> <span class="keyword">then</span>
        cb = stream_index
        stream_index = <span class="string">"stream"</span>
    <span class="keyword">end</span>

    <span class="keyword">return</span> <span class="keyword">function</span>(err, results)
        <span class="keyword">local</span> result
        <span class="keyword">if</span> result_index <span class="keyword">and</span> results[result_index] <span class="keyword">then</span>
            result = <span class="global">table</span>.unpack(results[result_index])
        <span class="keyword">end</span>

        <span class="keyword">if</span> <span class="keyword">not</span> results[stream_index] <span class="keyword">then</span>
            <span class="keyword">return</span> cb(err, result)
        <span class="keyword">end</span>

        <span class="comment">-- Make sure to always close the stream, even if the read operation failed.
</span>        <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results[stream_index])
        stream:close_async(GLib.PRIORITY_DEFAULT, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
            <span class="keyword">local</span> _, err_inner = stream:close_finish(token)
            <span class="comment">-- Prioritize the outer error (from the read operation), as the inner error (closing the stream) may be
</span>            <span class="comment">-- a result of that.
</span>            cb(err <span class="keyword">or</span> err_inner, result)
        <span class="keyword">end</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- Get the file's path name.
</span><span class="comment">--
</span><span class="comment">-- The path is guaranteed to be absolute, by may contain unresolved symlinks.
</span><span class="comment">-- However, a path may not exist, in which case `nil` will be returned.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><a id="191"></a><span class="comment">-- @treturn[opt] string
</span><span class="keyword">function</span> File:get_path()
    <span class="keyword">return</span> self._private.f:get_path()
<span class="keyword">end</span>

<span class="comment">--- Open a read stream.
</span><span class="comment">--
</span><span class="comment">-- The consumer is responsible for properly closing the stream:
</span><span class="comment">--
</span><span class="comment">--    stream:close_async(GLib.PRIORITY_DEFAULT, nil, function(_, token)
</span><span class="comment">--        local _, err = stream:close_finish(token)
</span><span class="comment">--        cb(err)
</span><span class="comment">--    end)
</span><span class="comment">--
</span><span class="comment">-- A [GDataInputStream](https://docs.gtk.org/gio/class.DataInputStream.html) adds additional reading utilities:
</span><span class="comment">--
</span><span class="comment">--    stream = Gio.DataInputStream.new(stream)
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="212"></a><span class="comment">-- @treturn[opt] Gio.FileInputStream
</span><span class="keyword">function</span> File:read_stream(cb)
    <span class="keyword">local</span> f = self._private.f

    f:read_async(GLib.PRIORITY_DEFAULT, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
        <span class="keyword">local</span> stream, err = f:read_finish(token)
        cb(err, stream)
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Open a write stream.
</span><span class="comment">--
</span><span class="comment">-- Write operations are buffered, so the stream needs to be flushed (or closed)
</span><span class="comment">-- to be sure that changes are written to disk. Especially in `replace` mode,
</span><span class="comment">-- reading before flushing will yield stale content.
</span><span class="comment">--
</span><span class="comment">-- The consumer is responsible for properly closing the stream:
</span><span class="comment">--
</span><span class="comment">--    stream:close_async(GLib.PRIORITY_DEFAULT, nil, function(_, token)
</span><span class="comment">--        local _, err = stream:close_finish(token)
</span><span class="comment">--        cb(err)
</span><span class="comment">--    end)
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam[opt="replace"] string mode Either `"append"` or `"replace"`.
</span><span class="comment">--  `"replace"` will truncate the file before writing, `"append"` will keep
</span><span class="comment">--  any existing content and add the new data at the end.
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="242"></a><span class="comment">-- @treturn Gio.FileOutputStream
</span><span class="keyword">function</span> File:write_stream(mode, cb)
    <span class="keyword">local</span> f = self._private.f
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    <span class="keyword">if</span> <span class="global">type</span>(mode) == <span class="string">"function"</span> <span class="keyword">then</span>
        cb = mode
        mode = <span class="keyword">nil</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> mode == <span class="string">"append"</span> <span class="keyword">then</span>
        f:append_to_async(
            Gio.FileCreateFlags.NONE,
            priority,
            <span class="keyword">nil</span>,
            <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> stream, err = f:append_to_finish(token)
                cb(err, stream)
            <span class="keyword">end</span>
        )
    <span class="keyword">else</span>
        f:replace_async(
            <span class="keyword">nil</span>,
            <span class="keyword">false</span>,
            Gio.FileCreateFlags.NONE,
            priority,
            <span class="keyword">nil</span>,
            <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> stream, err = f:replace_finish(token)
                cb(err, stream)
            <span class="keyword">end</span>
        )
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- Write the data to the opened file.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam string data The data to write.
</span><span class="comment">-- @tparam[opt="replace"] string mode Either `"append"` or `"replace"`.
</span><span class="comment">--  `"replace"` will truncate the file before writing, `"append"` will keep
</span><span class="comment">--  any existing content and add the new data at the end.
</span><span class="comment">-- @tparam function cb
</span><a id="286"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:write(data, mode, cb)
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    <span class="keyword">if</span> <span class="global">type</span>(mode) == <span class="string">"function"</span> <span class="keyword">then</span>
        cb = mode
        mode = <span class="keyword">nil</span>
    <span class="keyword">end</span>

    async.dag({
        stream = <span class="keyword">function</span>(_, cb_inner)
            self:write_stream(mode, cb_inner)
        <span class="keyword">end</span>,
        write = { <span class="string">"stream"</span>, <span class="keyword">function</span>(results, cb_inner)
            <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results.stream)

            stream:write_all_async(data, priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> _, _, err = stream:write_all_finish(token)
                cb_inner(err)
            <span class="keyword">end</span>)
        <span class="keyword">end</span> },
    }, clean_up_stream(<span class="keyword">nil</span>, cb))
<span class="keyword">end</span>


<span class="comment">--- Read at most the specified number of bytes from the file.
</span><span class="comment">--
</span><span class="comment">-- If there is not enough data to read, the result may contain less than `size` bytes of data.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam number size The number of bytes to read.
</span><span class="comment">-- @tparam function cb The callback to call when reading finished.
</span><span class="comment">--   Signature: `function(err, data)`
</span><span class="comment">-- @treturn[opt] GLib.Error An instance of `GError` if there was an error,
</span><span class="comment">--   `nil` otherwise.
</span><a id="322"></a><span class="comment">-- @treturn GLib.Bytes
</span><span class="keyword">function</span> File:read_bytes(size, cb)
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    async.dag({
        stream = <span class="keyword">function</span>(_, cb_inner)
            self:read_stream(cb_inner)
        <span class="keyword">end</span>,
        bytes = { <span class="string">"stream"</span>, <span class="keyword">function</span>(results, cb_inner)
            <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results.stream)

            stream:read_bytes_async(size, priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> bytes, err = stream:read_bytes_finish(token)
                cb_inner(err, bytes)
            <span class="keyword">end</span>)
        <span class="keyword">end</span> },
    }, clean_up_stream(<span class="string">"bytes"</span>, cb))
<span class="keyword">end</span>


<span class="comment">--- Read the entire file's content into memory.
</span><span class="comment">--
</span><span class="comment">-- This collects the content into a Lua <a href="https://www.lua.org/manual/5.3/manual.html#6.4">string</a>, so text files an be used as-is.
</span><span class="comment">-- For binary content, use <a href="https://www.lua.org/manual/5.3/manual.html#pdf-string.byte">string.byte</a> to access the raw values or manually wrap the result of
</span><span class="comment">-- <a href="../modules/file.html#File:read_stream">file:read_stream</a> in a [Gio.DataInputStream](https://docs.gtk.org/gio/class.DataInputStream.html) and
</span><span class="comment">-- read individual values based on their binary size.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb The callback to call when reading finished.
</span><span class="comment">--   Signature: `function(err, data)`
</span><span class="comment">-- @treturn[opt] GLib.Error An instance of `GError` if there was an error,
</span><span class="comment">--   `nil` otherwise.
</span><a id="355"></a><span class="comment">-- @treturn[opt] string A string read from the file.
</span><span class="keyword">function</span> File:read_string(cb)
    async.dag({
        stream = <span class="keyword">function</span>(_, cb_inner)
            self:read_stream(cb_inner)
        <span class="keyword">end</span>,
        <span class="global">string</span> = { <span class="string">"stream"</span>, <span class="keyword">function</span>(results, cb_inner)
            <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results.stream)
            stream_utils.read_string(stream, cb_inner)
        <span class="keyword">end</span> },
    }, clean_up_stream(<span class="string">"string"</span>, cb))
<span class="keyword">end</span>


<span class="comment">--- Read a line from the file.
</span><span class="comment">--
</span><span class="comment">-- Like all other operations, this always reads from the beginning of the file. Calling this function
</span><span class="comment">-- repeatedly on the same file will always yield the first line.
</span><span class="comment">--
</span><span class="comment">-- To iterate over all lines, use <a href="../modules/file.html#File:iterate_lines">file:iterate_lines</a>. To read more than just one line, use <a href="../modules/file.html#File:read_bytes">file:read_bytes</a> or
</span><span class="comment">-- <a href="../modules/file.html#File:read_string">file:read_string</a>.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error An instance of `GError` if there was an error,
</span><span class="comment">--   `nil` otherwise.
</span><span class="comment">-- @treturn[opt] string A string read from the file,
</span><a id="382"></a><span class="comment">--   or `nil` if the end was reached.
</span><span class="keyword">function</span> File:read_line(cb)
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    async.dag({
        stream = <span class="keyword">function</span>(_, cb_inner)
            self:read_stream(cb_inner)
        <span class="keyword">end</span>,
        line = { <span class="string">"stream"</span>, <span class="keyword">function</span>(results, cb_inner)
            <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results.stream)
            stream = Gio.DataInputStream.new(stream)

            stream:read_line_async(priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> line, _, err = stream:read_line_finish(token)
                cb_inner(err, line)
            <span class="keyword">end</span>)
        <span class="keyword">end</span> },
    }, clean_up_stream(<span class="string">"line"</span>, cb))
<span class="keyword">end</span>


<span class="comment">--- Asynchronously iterate over the file line by line.
</span><span class="comment">--
</span><span class="comment">-- This function opens a read stream and starts reading the file line-wise,
</span><span class="comment">-- asynchronously. For every line read, the given `iteratee` is called with any
</span><span class="comment">-- potential error, the line's content (without the trailing newline)
</span><span class="comment">-- and a callback function. The callback must always be called to ensure the
</span><span class="comment">-- file handle is cleaned up eventually. The expected signature for the callback
</span><span class="comment">-- is `cb(err, stop)`. If `err ~= nil` or a value for `stop` is given, iteration stops
</span><span class="comment">-- immediately and `cb` will be called.
</span><span class="comment">--
</span><span class="comment">-- Changed 0.2.0: Renamed from `read_lines`.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function iteratee Function to call per line in the file. Signature:
</span><span class="comment">--   `function(err, line, cb)`
</span><span class="comment">-- @tparam function cb Function to call when iteration has stopped.
</span><a id="420"></a><span class="comment">--   Signature: `function(err)`.
</span><span class="keyword">function</span> File:iterate_lines(iteratee, cb)
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    async.dag({
        stream = <span class="keyword">function</span>(_, cb_inner)
            self:read_stream(cb_inner)
        <span class="keyword">end</span>,
        lines = { <span class="string">"stream"</span>, <span class="keyword">function</span>(results, cb_inner)
            <span class="keyword">local</span> stream = <span class="global">table</span>.unpack(results.stream)
            stream = Gio.DataInputStream.new(stream)

            <span class="keyword">local</span> <span class="keyword">function</span> read_line(cb_line)
                stream:read_line_async(priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
                    <span class="keyword">local</span> line, _, err = stream:read_line_finish(token)

                    iteratee(err, line, <span class="keyword">function</span>(err, stop)
                        cb_line(err, stop <span class="keyword">or</span> <span class="keyword">false</span>, line)
                    <span class="keyword">end</span>)
                <span class="keyword">end</span>)
            <span class="keyword">end</span>

            <span class="keyword">local</span> <span class="keyword">function</span> check(stop, line, cb_check)
                <span class="keyword">if</span> <span class="global">type</span>(line) == <span class="string">"function"</span> <span class="keyword">then</span>
                    cb_check = line
                    line = <span class="keyword">nil</span>
                <span class="keyword">end</span>

                <span class="keyword">local</span> continue = (<span class="keyword">not</span> stop) <span class="keyword">and</span> (line ~= <span class="keyword">nil</span>)
                cb_check(<span class="keyword">nil</span>, continue)
            <span class="keyword">end</span>

            async.do_while(read_line, check, <span class="keyword">function</span>(err)
                cb_inner(err)
            <span class="keyword">end</span>)
        <span class="keyword">end</span> },
    }, clean_up_stream(<span class="keyword">nil</span>, cb))
<span class="keyword">end</span>


<span class="comment">--- Move the file to a new location.
</span><span class="comment">--
</span><span class="comment">-- Due to limitations in GObject Introspection, this can currently only be implemented as
</span><span class="comment">-- "copy and delete" operation.
</span><span class="comment">--
</span><span class="comment">-- @since 0.3.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam string|file path New path to move to.
</span><span class="comment">-- @tparam function cb
</span><a id="469"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:move(path, cb)
    async.waterfall({
        <span class="keyword">function</span>(cb)
            self:copy(path, { recursive = <span class="keyword">true</span> }, cb)
        <span class="keyword">end</span>,
        <span class="keyword">function</span>(cb)
            self:delete(cb)
        <span class="keyword">end</span>
    }, <span class="keyword">function</span>(err) cb(err) <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="keyword">local</span> <span class="keyword">function</span> _file_copy_impl(self, dest, options, cb)
    async.dag({
        check_overwrite = <span class="keyword">function</span>(_, cb)
            <span class="keyword">if</span> options.overwrite <span class="keyword">then</span>
                <span class="keyword">return</span> cb(<span class="keyword">nil</span>)
            <span class="keyword">end</span>

            dest:exists(<span class="keyword">function</span>(err, exists)
                <span class="keyword">if</span> <span class="keyword">not</span> err <span class="keyword">and</span> exists <span class="keyword">then</span>
                    err = GLib.Error(
                        Gio.IOErrorEnum,
                        Gio.IOErrorEnum.EXISTS,
                        <span class="string">"Destination exists already"</span>
                    )
                <span class="keyword">end</span>

                cb(err)
            <span class="keyword">end</span>)
        <span class="keyword">end</span>,
        out_stream = { <span class="string">"check_overwrite"</span>, <span class="keyword">function</span>(_, cb)
            dest:write_stream(<span class="string">"replace"</span>, cb)
        <span class="keyword">end</span> },
        in_stream = { <span class="string">"check_overwrite"</span>, <span class="keyword">function</span>(_, cb)
            self:read_stream(cb)
        <span class="keyword">end</span> },
        splice = { <span class="string">"out_stream"</span>, <span class="string">"in_stream"</span>, <span class="keyword">function</span>(results, cb)
            <span class="keyword">local</span> in_stream = <span class="global">table</span>.unpack(results.in_stream)
            <span class="keyword">local</span> out_stream = <span class="global">table</span>.unpack(results.out_stream)
            <span class="keyword">local</span> flags = {
                Gio.OutputStreamSpliceFlags.CLOSE_SOURCE,
                Gio.OutputStreamSpliceFlags.CLOSE_TARGET
            }

            out_stream:splice_async(in_stream, flags, GLib.PRIORITY_DEFAULT, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
                <span class="keyword">local</span> _, err = out_stream:splice_finish(token)
                cb(err)
            <span class="keyword">end</span>)
        <span class="keyword">end</span> },
    }, <span class="keyword">function</span>(err) cb(err) <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Copies the file to a new location.
</span><span class="comment">--
</span><span class="comment">-- @since 0.3.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam string|file dest_path Path to copy to.
</span><span class="comment">-- @tparam table options
</span><span class="comment">-- @tparam boolean recursive Copy directory contents recursively.
</span><span class="comment">-- @tparam boolean overwrite Overwrite files at the destination path.
</span><span class="comment">-- @tparam function cb
</span><a id="533"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:copy(dest_path, options, cb)
    <span class="keyword">local</span> dest = dest_path
    <span class="keyword">if</span> <span class="global">type</span>(dest) == <span class="string">"string"</span> <span class="keyword">then</span>
        dest = file.new_for_path(dest_path)
    <span class="keyword">end</span>

    <span class="keyword">if</span> <span class="keyword">not</span> options.recursive <span class="keyword">then</span>
        <span class="keyword">return</span> _file_copy_impl(self, dest, options, cb)
    <span class="keyword">end</span>

    async.dag({
        file_type = <span class="keyword">function</span>(_, cb)
            self:<span class="global">type</span>(cb)
        <span class="keyword">end</span>,
        copy = { <span class="string">"file_type"</span>, <span class="keyword">function</span>(results, cb)
            <span class="keyword">local</span> file_type = <span class="global">table</span>.unpack(results.file_type)

            <span class="keyword">if</span> file_type ~= Gio.FileType.DIRECTORY <span class="keyword">then</span>
                <span class="keyword">return</span> _file_copy_impl(self, dest, options, cb)
            <span class="keyword">elseif</span> <span class="keyword">not</span> options.recursive <span class="keyword">then</span>
                <span class="keyword">local</span> err = GLib.Error(
                    Gio.IOErrorEnum,
                    Gio.IOErrorEnum.IS_DIRECTORY,
                    <span class="string">"Directories can only be copied recursively"</span>
                )
                <span class="keyword">return</span> cb(err)
            <span class="keyword">end</span>

            <span class="keyword">local</span> filesystem = <span class="global">require</span>(<span class="string">"lgi-async-extra.filesystem"</span>)
            <span class="keyword">local</span> path = self:get_path()

            <span class="keyword">local</span> <span class="keyword">function</span> iteratee(info, cb)
                <span class="keyword">local</span> child = file.new_for_path(<span class="global">string</span>.format(<span class="string">"%s/%s"</span>, path, info:get_name()))
                <span class="keyword">local</span> child_dest = file.new_for_path(
                    <span class="global">string</span>.format(<span class="string">"%s/%s"</span>, dest_path, info:get_name())
                )
                child:copy(child_dest, options, cb)
            <span class="keyword">end</span>

            filesystem.iterate_contents(path, iteratee, cb)
        <span class="keyword">end</span> },
    }, <span class="keyword">function</span>(err) cb(err) <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Delete the file.
</span><span class="comment">--
</span><span class="comment">-- This has the same semantics as POSIX `unlink()`, i.e. the link at the given
</span><span class="comment">-- path is removed. If it was the last link to the file, the disk space occupied
</span><span class="comment">-- by that file is freed as well.
</span><span class="comment">--
</span><span class="comment">-- Empty directories are deleted by this as well.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><a id="589"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:delete(cb)
    <span class="keyword">local</span> f = self._private.f
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    f:delete_async(priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
        <span class="keyword">local</span> _, err = f:delete_finish(token)
        cb(err)
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Move the file to trash.
</span><span class="comment">--
</span><span class="comment">-- Support for this depends on the platform and file system. If unsupported
</span><span class="comment">-- an error of type `Gio.IOErrorEnum.NOT_SUPPORTED` will be returned.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><a id="608"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:trash(cb)
    <span class="keyword">local</span> f = self._private.f
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    f:trash_async(priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
        <span class="keyword">local</span> _, err = f:trash_finish(token)
        cb(err)
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Query file information.
</span><span class="comment">--
</span><span class="comment">-- This can be used to query for any file info attribute supported by GIO.
</span><span class="comment">-- The attribute parameter may either be plain string, such as `"standard::size"`, a wildcard `"standard::*"` or
</span><span class="comment">-- a list of both `"standard::*,owner::user"`.
</span><span class="comment">--
</span><span class="comment">-- GIO also offers constants for these attribute values, which can be found by querying the GIO docs for
</span><span class="comment">-- `G_FILE_ATTRIBUTE_*` constants:
</span><span class="comment">-- [https://docs.gtk.org/gio/index.html?q=G_FILE_ATTRIBUTE_](https://docs.gtk.org/gio/index.html?q=G_FILE_ATTRIBUTE_)
</span><span class="comment">--
</span><span class="comment">-- See [docs.gtk.org](https://docs.gtk.org/gio/method.File.query_info.html) for additional details.
</span><span class="comment">--
</span><span class="comment">-- @todo Document the conversion from GIO's attributes to what LGI expects.
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam string attribute The GIO file info attribute to query for.
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="637"></a><span class="comment">-- @treturn[opt] Gio.FileInfo
</span><span class="keyword">function</span> File:query_info(attribute, cb)
    <span class="keyword">local</span> f = self._private.f
    <span class="keyword">local</span> priority = GLib.PRIORITY_DEFAULT

    f:query_info_async(attribute, <span class="number">0</span>, priority, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
        <span class="keyword">local</span> info, err = f:query_info_finish(token)
        cb(err, info)
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Check if the file exists.
</span><span class="comment">--
</span><span class="comment">-- Keep in mind that checking for existence before reading or writing a file is
</span><span class="comment">-- subject to race conditions.
</span><span class="comment">-- An external process may still alter a file between those two operations.
</span><span class="comment">--
</span><span class="comment">-- Also note that, due to limitations in GLib, this method cannot distinguish
</span><span class="comment">-- between a file that is actually absent and a file that the user has no access
</span><span class="comment">-- to.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="662"></a><span class="comment">-- @treturn boolean `true` if the file exists at its specified location.
</span><span class="keyword">function</span> File:exists(cb)
    self:query_info(<span class="string">"standard::type"</span>, <span class="keyword">function</span> (err)
        <span class="keyword">if</span> err <span class="keyword">then</span>
            <span class="comment">-- An error of "not found" is actually an expected outcome, so
</span>            <span class="comment">-- we hide the error.
</span>            <span class="keyword">if</span> err.code == Gio.IOErrorEnum[Gio.IOErrorEnum.NOT_FOUND] <span class="keyword">then</span>
                cb(<span class="keyword">nil</span>, <span class="keyword">false</span>)
            <span class="keyword">else</span>
                cb(err, <span class="keyword">false</span>)
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            cb(<span class="keyword">nil</span>, <span class="keyword">true</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Query the size of the file.
</span><span class="comment">--
</span><span class="comment">-- Note that due to limitations in GLib, this will return `0` for files
</span><span class="comment">-- that the user has no access to.
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="688"></a><span class="comment">-- @treturn[opt] number
</span><span class="keyword">function</span> File:size(cb)
    self:query_info(<span class="string">"standard::size"</span>, <span class="keyword">function</span> (err, info)
        <span class="comment">-- For some reason, the bindings return a float for a byte size
</span>        cb(err, info <span class="keyword">and</span> <span class="global">math</span>.floor(info:get_size()))
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Query the type of the file.
</span><span class="comment">--
</span><span class="comment">-- Common scenarios would be to compare this against `Gio.FileType`.
</span><span class="comment">--
</span><span class="comment">-- Note that due to limitations in GLib, this will return `Gio.FileType.UNKNOWN` for files
</span><span class="comment">-- that the user has no access to.
</span><span class="comment">--
</span><span class="comment">-- @usage
</span><span class="comment">--    f:type(function(err, type)
</span><span class="comment">--        if err then return cb(err) end
</span><span class="comment">--        local is_dir = type == Gio.FileType.DIRECTORY
</span><span class="comment">--        local is_link = type == Gio.FileType.SYMBOLIC_LINK
</span><span class="comment">--        local is_file = type == Gio.FileType.REGULAR
</span><span class="comment">--        -- get a string representation
</span><span class="comment">--        print(Gio.FileType[type])
</span><span class="comment">--    end)
</span><span class="comment">--
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><span class="comment">-- @treturn[opt] GLib.Error
</span><a id="717"></a><span class="comment">-- @treturn[opt] Gio.FileType
</span><span class="keyword">function</span> File:<span class="global">type</span>(cb)
    self:query_info(<span class="string">"standard::type"</span>, <span class="keyword">function</span> (err, info)
        cb(err, info <span class="keyword">and</span> Gio.FileType[info:get_file_type()])
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="comment">--- Creates an empty file.
</span><span class="comment">--
</span><span class="comment">-- The file must not exist already.
</span><span class="comment">--
</span><span class="comment">-- Write operations, such as <a href="../modules/file.html#File:write">file.write</a> and <a href="../modules/file.html#File:write_stream">file.write_stream</a> also create files
</span><span class="comment">-- when they don't yet, so those should be used when you intend to write to the new file immediately.
</span><span class="comment">--
</span><span class="comment">-- @since 0.2.0
</span><span class="comment">-- @async
</span><span class="comment">-- @tparam function cb
</span><a id="735"></a><span class="comment">-- @treturn[opt] GLib.Error
</span><span class="keyword">function</span> File:create(cb)
    <span class="keyword">local</span> f = self._private.f
    f:create_async(Gio.FileCreateFlags.NONE, GLib.PRIORITY_DEFAULT, <span class="keyword">nil</span>, <span class="keyword">function</span>(_, token)
        <span class="keyword">local</span> _, err = f:create_finish(token)
        cb(err)
    <span class="keyword">end</span>)
<span class="keyword">end</span>


<span class="keyword">return</span> file</pre>
</div>
    </section>

    <footer class="footer">
        <div class="content has-text-centered">
            Generated by <a href="https://github/com/stevendonovan/LDoc">LDoc 1.4.6</a>, designed with <a href="https://github.com/jgthms/bulma">Bulma</a>. Last updated at 2022-04-13 12:28:50.
        </div>
    </footer>
</div>

</body>
</html>
