<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>lgi-async-extra</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>lgi-async-extra</h1>


<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Constructors">Constructors </a></li>
<li><a href="#Class_File">Class File </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>file</strong></li>
  <li><a href="../modules/stream.html">stream</a></li>
</ul>
<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/stream.lua.html">stream.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>file</code></h1>
<p>High level file handling library.</p>
<p><p> A file handle can be created through one of the constructor functions. File
 operations are performed on that handle.</p>

<p> The API is callback based, so the use of <code>gears.async</code> for composition is
 recommended. All callbacks receive an <code>err</code> value as first argument,
 which is non-<code>nil</code> when an error ocurred, and any non-error return values
 after that.</p>

<p> Example to write and read-back a file:</p>

<pre>
<span class="keyword">local</span> f = File.new_for_path(<span class="string">"/tmp/foo.txt"</span>)
async.waterfall({
    <span class="keyword">function</span>(cb)
        f:write(<span class="string">"hello"</span>, cb)
    <span class="keyword">end</span>,
    <span class="keyword">function</span>(cb)
        f:write(<span class="string">"world"</span>, <span class="string">"append"</span>, cb)
    <span class="keyword">end</span>,
    <span class="keyword">function</span>(cb)
        f:read_all(cb)
    <span class="keyword">end</span>,
}, <span class="keyword">function</span>(err, data)
    <span class="global">print</span>(err)
    <span class="global">print</span>(data)
<span class="keyword">end</span>)
</pre>


<p> Error values passed to callback functions will almost always be instances of
 <code>GLib.Error</code>:</p>

<pre>
read_non_existent_file(<span class="keyword">function</span>(err, data)
    <span class="global">print</span>(err) <span class="comment">-- or `print(err.message)`
</span>    <span class="global">assert</span>(err.domain == Gio.IOErrorEnum)
    <span class="comment">-- Checking the error code against a constant is the recommended way,
</span>    <span class="comment">-- but a bit verbose, due to LGI's mapping.
</span>    <span class="comment">-- See: https://github.com/pavouk/lgi/blob/master/docs/guide.md
</span>    <span class="global">assert</span>(err.code == Gio.IOErrorEnum[Gio.IOErrorEnum.NOT_FOUND])
<span class="keyword">end</span>)
</pre>

</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>License</strong>: GPL-v3-or-later</li>
    </ul>


<h2><a href="#Constructors">Constructors </a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#new_for_path">new_for_path(path)</a></td>
	<td class="summary">Create a file handle for the given local path.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#new_for_uri">new_for_uri(uri)</a></td>
	<td class="summary">Create a file handle for the given remote URI.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#new_tmp">new_tmp([template])</a></td>
	<td class="summary">Create a new file in a directory preferred for temporary storage.</td>
	</tr>
</table>
<h2><a href="#Class_File">Class File </a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#File:read_stream">File:read_stream(cb)</a></td>
	<td class="summary">Open a read stream.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:write_stream">File:write_stream([mode="replace"], cb)</a></td>
	<td class="summary">Open a write stream.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:write">File:write(data[, mode="replace"], cb)</a></td>
	<td class="summary">Write the data to the opened file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:read_all">File:read_all(cb)</a></td>
	<td class="summary">Read the entire file&rsquo;s content into memory.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:read_line">File:read_line(cb)</a></td>
	<td class="summary">Read a line from the file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:read_lines">File:read_lines(iteratee, final_callback)</a></td>
	<td class="summary">Asynchronously iterate over the file line by line.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:move">File:move(destination, cb)</a></td>
	<td class="summary">Move the file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:delete">File:delete(cb)</a></td>
	<td class="summary">Delete the file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:trash">File:trash(cb)</a></td>
	<td class="summary">Move the file to trash.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:query_info">File:query_info(attribute, cb)</a></td>
	<td class="summary">Query file information.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:exists">File:exists(cb)</a></td>
	<td class="summary">Check if the file exists.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:size">File:size(cb)</a></td>
	<td class="summary">Query the size of the file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:type">File:type(cb)</a></td>
	<td class="summary">Query the type of the file.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#File:get_path">File:get_path()</a></td>
	<td class="summary">Get the file&rsquo;s path name.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Constructors"></a>Constructors </h2>

    <dl class="function">
    <dt>
    <a name = "new_for_path"></a>
    <strong>new_for_path(path)</strong>
    <a style="float:right;" href="../source/file.lua.html#67">line 67</a>
    </dt>
    <dd>
    Create a file handle for the given local path.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">path</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>


        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../modules/file.html#File">File</a></span>


    </ol>




</dd>
    <dt>
    <a name = "new_for_uri"></a>
    <strong>new_for_uri(uri)</strong>
    <a style="float:right;" href="../source/file.lua.html#83">line 83</a>
    </dt>
    <dd>
    Create a file handle for the given remote URI.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">uri</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>


        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../modules/file.html#File">File</a></span>


    </ol>




</dd>
    <dt>
    <a name = "new_tmp"></a>
    <strong>new_tmp([template])</strong>
    <a style="float:right;" href="../source/file.lua.html#116">line 116</a>
    </dt>
    <dd>
    Create a new file in a directory preferred for temporary storage. </p>

<p> If <code>template</code> is given, it must contain a sequence of six <code>X</code>s somewhere in the string, which
 will replaced by a unique ID to ensure the file does not overwrite anything. It must not contain any
 directory components.
 Otherwise, a default value will be used.</p>

<p> The directory is determined by <a href="https://docs.gtk.org/glib/func.get_tmp_dir.html">g_get_tmp_dir</a>.</p>

<p> The second return value is a <code>GIO.FileIOStream</code>, which contains both an input and output stream to the created
 file. The caller is responsible for closing these streams.</p>

<p> The third return value will be an instance of <code>GLib.Error</code> if the attempt to create the file failed. If this
 is not <code>nil</code>, attempts to access the other return values will result in undefined behavior.</p>

<p> See: <a href="https://docs.gtk.org/gio/type_func.File.new_tmp.html">Gio.File.new_tmp</a>

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">template</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>


         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><a class="type" href="../modules/file.html#File">File</a></span>

</li>
        <li>
           <span class="types"><span class="type">GIO.FileIOStream</span></span>

</li>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>

</li>
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Class_File"></a>Class File </h2>

    <dl class="function">
    <dt>
    <a name = "File:read_stream"></a>
    <em>async</em>
    <strong>File:read_stream(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#146">line 146</a>
    </dt>
    <dd>
    <p>Open a read stream. </p>

<p> The consumer is responsible for properly closing the stream:</p>

<pre><code>stream:close_async(GLib.PRIORITY_DEFAULT, nil, function(_, token)
    local _, err = stream:close_finish(token)
    cb(err)
end)
</code></pre>

<p> The <a href="https://docs.gtk.org/gio/class.DataInputStream.html"><code>GDataInputStream</code></a> adds additional reading utilities:</p>

<pre><code>stream = Gio.DataInputStream.new(stream)
</code></pre>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types">optional <span class="type">Gio.FileInputStream</span></span>
        stream</li>
    </ol>




</dd>
    <dt>
    <a name = "File:write_stream"></a>
    <em>async</em>
    <strong>File:write_stream([mode="replace"], cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#176">line 176</a>
    </dt>
    <dd>
    <p>Open a write stream. </p>

<p> Write operations are buffered, so the stream needs to be flushed (or closed)
 to be sure that changes are written to disk. Especially in <code>replace</code> mode,
 reading before flushing will yield stale content.</p>

<p> The consumer is responsible for properly closing the stream:</p>

<pre><code>stream:close_async(GLib.PRIORITY_DEFAULT, nil, function(_, token)
    local _, err = stream:close_finish(token)
    cb(err)
end)
</code></pre>


    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mode</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Either <code>"append"</code> or <code>"replace"</code>.
  <code>"replace"</code> will truncate the file before writing, <code>"append"</code> will keep
  any existing content and add the new data at the end.
         (<em>default</em> "replace")
        </li>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types"><span class="type">Gio.FileOutputStream</span></span>
        stream</li>
    </ol>




</dd>
    <dt>
    <a name = "File:write"></a>
    <em>async</em>
    <strong>File:write(data[, mode="replace"], cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#220">line 220</a>
    </dt>
    <dd>
    Write the data to the opened file.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The data to write.
        </li>
        <li><span class="parameter">mode</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Either <code>"append"</code> or <code>"replace"</code>.
  <code>"replace"</code> will truncate the file before writing, <code>"append"</code> will keep
  any existing content and add the new data at the end.
         (<em>default</em> "replace")
        </li>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>

           <span class="types">optional <span class="type">GLib.Error</span></span>
        err
    </ol>




</dd>
    <dt>
    <a name = "File:read_all"></a>
    <em>async</em>
    <strong>File:read_all(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#261">line 261</a>
    </dt>
    <dd>
    Read the entire file&rsquo;s content into memory.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>
         The callback to call when reading finished.
   Signature: <code>function(err, data)</code>
        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err An instance of <code>GError</code> if there was an error,
   <code>nil</code> otherwise.</li>
        <li>
           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        data A string read from the file.</li>
    </ol>




</dd>
    <dt>
    <a name = "File:read_line"></a>
    <em>async</em>
    <strong>File:read_line(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#319">line 319</a>
    </dt>
    <dd>
    Read a line from the file. </p>

<p> Inefficient when reading lines repeatedly from the same file.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err An instance of <code>GError</code> if there was an error,
   <code>nil</code> otherwise.</li>
        <li>
           <span class="types">optional <a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        line A string read from the file,
   or <code>nil</code> if the end was reached.</li>
    </ol>




</dd>
    <dt>
    <a name = "File:read_lines"></a>
    <strong>File:read_lines(iteratee, final_callback)</strong>
    <a style="float:right;" href="../source/file.lua.html#362">line 362</a>
    </dt>
    <dd>
    Asynchronously iterate over the file line by line. </p>

<p> This function opens a read stream and starts reading the file line-wise,
 asynchronously. For every line read, the given <code>iteratee</code> is called with any
 potential error, the line&rsquo;s content (without the trailing newline)
 and a callback function. The callback must always be called to ensure the
 file handle is cleaned up eventually. The expected signature for the callback
 is <code>cb(err, stop)</code>. If <code>err ~= nil or stop ~= nil</code>, iteration stops
 immediately and <code>final_callback</code> will be called.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iteratee</span>
            <span class="types"><span class="type">function</span></span>
         Function to call per line in the file. Signature:
   <code>function(err, line, cb)</code>
        </li>
        <li><span class="parameter">final_callback</span>
            <span class="types"><span class="type">function</span></span>
         Function to call when iteration has stopped.
   Signature: <code>function(err)</code>.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "File:move"></a>
    <em>async</em>
    <strong>File:move(destination, cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#414">line 414</a>
    </dt>
    <dd>
    Move the file. </p>

<p> Depends on https://gitlab.gnome.org/GNOME/glib/&ndash;/merge_requests/2469.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">destination</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         New path to move to
        </li>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>

           <span class="types">optional <span class="type">GLib.Error</span></span>
        err
    </ol>




</dd>
    <dt>
    <a name = "File:delete"></a>
    <em>async</em>
    <strong>File:delete(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#438">line 438</a>
    </dt>
    <dd>
    Delete the file. </p>

<p> This has the same semantics as POSIX <code>unlink()</code>, i.e. the link at the given
 path is removed. If it was the last link to the file, the disk space occupied
 by that file is freed as well.</p>

<p> Empty directories are deleted by this as well.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>

           <span class="types">optional <span class="type">GLib.Error</span></span>
        err
    </ol>




</dd>
    <dt>
    <a name = "File:trash"></a>
    <em>async</em>
    <strong>File:trash(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#457">line 457</a>
    </dt>
    <dd>
    Move the file to trash. </p>

<p> Support for this depends on the platform and file system. If unsupported
 an error of type <code>Gio.IOErrorEnum.NOT_SUPPORTED</code> will be returned.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>

           <span class="types">optional <span class="type">GLib.Error</span></span>
        err
    </ol>




</dd>
    <dt>
    <a name = "File:query_info"></a>
    <em>async</em>
    <strong>File:query_info(attribute, cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#486">line 486</a>
    </dt>
    <dd>
    Query file information. </p>

<p> This can be used to query for any file info attribute supported by GIO.
 The attribute parameter may either be plain string, such as <code>"standard::size"</code>, a wildcard <code>"standard::*"</code> or
 a list of both <code>"standard::*,owner::user"</code>.</p>

<p> GIO also offers constants for these attribute values, which can be found by querying the GIO docs for
 <code>G_FILE_ATTRIBUTE_*</code> constants:
 <a href="https://docs.gtk.org/gio/index.html?q=G_FILE_ATTRIBUTE_">https://docs.gtk.org/gio/index.html?q=G_FILE_ATTRIBUTE_</a></p>

<p> See: <a href="https://docs.gtk.org/gio/method.File.query_info.html"><code>g_file_query_info()</code></a>

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">attribute</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The GIO file info attribute to query for.
        </li>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types">optional <span class="type">Gio.FileInfo</span></span>

</li>
    </ol>




</dd>
    <dt>
    <a name = "File:exists"></a>
    <em>async</em>
    <strong>File:exists(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#511">line 511</a>
    </dt>
    <dd>
    Check if the file exists. </p>

<p> Keep in mind that checking for existence before reading or writing a file is
 subject to race conditions.
 An external process may still alter a file between those two operations.</p>

<p> Also note that, due to limitations in GLib, this method cannot distinguish
 between a file that is actually absent and a file that the user has no access
 to.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if the file exists on disk</li>
    </ol>




</dd>
    <dt>
    <a name = "File:size"></a>
    <em>async</em>
    <strong>File:size(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#537">line 537</a>
    </dt>
    <dd>
    Query the size of the file. </p>

<p> Note that due to limitations in GLib, this will return <code>0</code> for files
 that the user has no access to.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types">optional <span class="type">number</span></span>
        size</li>
    </ol>




</dd>
    <dt>
    <a name = "File:type"></a>
    <em>async</em>
    <strong>File:type(cb)</strong>
    <a style="float:right;" href="../source/file.lua.html#565">line 565</a>
    </dt>
    <dd>
    Query the type of the file. </p>

<p> Common scenarios would be to compare this against <code>Gio.FileType</code>:</p>

<pre><code>f:type(function(err, type)
    if err then cb(err) end
    local is_dir = type == Gio.FileType.DIRECTORY
    local is_link = type == Gio.FileType.SYMBOLIC_LINK
    local is_file = type == Gio.FileType.REGULAR
    -- get a string representation
    print(Gio.FileType[type])
end)
</code></pre>

<p> Note that due to limitations in GLib, this will return <code>UNKNOWN</code> for files
 that the user has not access to.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">cb</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>

    <h3>Callback returns:</h3>
    <ol>
        <li>
           <span class="types">optional <span class="type">GLib.Error</span></span>
        err</li>
        <li>
           <span class="types">optional <a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        type</li>
    </ol>




</dd>
    <dt>
    <a name = "File:get_path"></a>
    <strong>File:get_path()</strong>
    <a style="float:right;" href="../source/file.lua.html#578">line 578</a>
    </dt>
    <dd>
    Get the file&rsquo;s path name. </p>

<p> The path is guaranteed to be absolute, by may contain unresolved symlinks.
 However, a path may not exist, in which case <code>nil</code> will be returned.

    </ul>


    <h3>Returns:</h3>
    <ol>

           <span class="types">optional <a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>


    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-03-04 13:50:50 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
